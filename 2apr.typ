= Структуры записи и объединения

В Ассемблере существует возможность объединения данных различного типа одним символическим именем.
Это так называемый *комбинированный тип данных* или *структура*.

Структура состоит из *полей* данных различного типа и длинны. Занимает в памяти последовательные
ячейки.

Для того, чтобы использовать переменные структурного типа, в начале нужно описать тип структуры,
а затем переменные такого типа. Шаблон описания типа структуры выглядит так:

```nasm
<имя типа> struc
  <описание поля>
  -----/-----
  <описание поля>
<имя типа> ends
```

*\<имя типа>* --- это символическое имя Ассемблера, имя создаваемого нами типа. Имя типа обязательно
и в начале, и в конце, так как `ends` также описывает конец сегмента.

Поля структуры описываются с помощью директив описания данных и паямти: `DB`, `DW`, `DD` и так
далее. Имя, мы укажем в директиве указания данных в памяти, будет именем поля.

Поля могут быть структурами, а могут и не быть, это зависит от версии компилятора. То есть, могут
быть вложенные структуры.

*Пример*:

```nasm
TData struc
  y DW 2000
  m DB ?
  d DB 28
TData ends
```

+ Имя нового типа --- `TData`
+ `y`, `m`, `d` --- имена полей
+ Значения, указанные в качестве операндов, называются *значениями полей по-умолчанию*, если стоит
  знак вопроса, значит по-умолчанию значения нет.

Описание типа может располагаться в любом месте программы, но до описания переменных. Место в памяти
не выделяется, оно будет выделено на основании описания переменных, но в соответствии со структурой,
указанной в описании типа.

*Описание переменной* такого типа выглядит следующим образом:

```
имя_переменной имя_нашего_типа <начальное значение>
```

_Здесь угловые скобки не метасимволы, а конструкция языка, в которых через запятую записываются
начальные значения полей._

Начальным значением может быть знак вопроса, выражение, строка или пусто. Например:

```nasm
dt1 TData <?, 6, 4>
dt2 TData <1999, , >
dt3 TData < , , >
```

#table(
  [y], [m], [d],
  [?], [6], [4],
  [1999], [?], [28],
  [2000], [?], [28]
)

Идентификатор `TData` используем, как директива для описания переменных. Если значения, записанные
в угловых скобках, не будут помещаться в описанные в типе поля, будет сообщение об ошибке.

== Правила использования значений по-умолчанию

+ Если некоторое поле имеет начальное значение --- знак вопроса, то какие бы значения не стояли
  по-умолчанию, они игнорируются.

+ Приоритетным является начальное значение. Если в качестве начального значения стоит какое-то
  выражение, то именно оно будет начальным для этого поля, несмотря на значение по-умолчанию.

+ Если в поле стоит знак вопроса, то в нём не будет никакого значения, несмотря на значение
  по-умолчанию.

+ Если начальным значением является пустота, то в качестве начального значения принимается
  значение по-умолчанию.

+ Значения по-умолчанию устанавливаются в том случае, если они справедливы для многих переменных
  или не изменяются в программе. Хотя любое значение поля в программе может быть изменено.

+ Отсутствие начального значения отмечается запятой. Если отсутствует начальное значение одного
  или нескольких последних полей, то и запятые можно не ставить.

+ Если отсутствует начальное поле или поле в середине, то запятая обязательна.

== Массив структур

  ```nasm
  dt4 TData <1980, ,>  ; аналогично dt4 TData <1980>
  dt5 TData <,,5>      ; нельзя написать dt5 TData <5>
  ```

+ Если отсутствуют все начальные значения, то запятые вовсе необязательны, но угловые скобки
  остаться должны.

  ```nasm
  dt6 TData <>         ; все поля примут значение по-умолчанию
  ```

Если нужно описать массив переменных структурного типа, это можно сделать одной строкой, например
так:

```nasm
dst TData <, 4, 1>, 25 dup (<>)
```

Мы описали массив структур из 26 элементов: первый имеет два начальных значения, значения
остальных элементов останутся значениями по-умолчанию.

Имя первой структуры --- dst. Для получения второго элемента надо написать `dst + 4` (все
поля в сумме занимают 4 байта).

== Поля структуры

С ними можно работать, как в ЯП высокого уровня:

```
<имя_переменной>.<имя_поля>
```

_Здесь угловые скобки --- метасимволы._

*Пример*:

```nasm
dt1.y
dt2.m
dt3.d
```

Но в отличие от ЯП высокого уровня, Ассемблер приписывает полю тип, определяющий размер,
занимаемой переменной.

```
type TData = type dt1 = 4
```

Полям одной переменной можно присвоить значение полей другой переменной побайтно.

*Пример* перессылка из dt1 в dt2:

```nasm
mov CX, type TData
mov SI, 0
m:
  ; Посылать из памяти в память нельзя, поэтому сначала сохраняем в регистр
  mov AL, byte ptr dt1[SI]
  mov byte ptr dt2[SI], AL
  inc SI
  loop m
```

Точка, указанная в обращении к полю --- это оператор Ассемблера, который вычисляет адрес поля по
формуле: `<адресное выражение> + <смещение поля в структуре>`. Тип полученного адреса совпадает
с типом поля: `type (dt1.m) = type m = byte`. Адресное выражение может быть любой сложности.
Например:

+ ```nasm
  mov AX, (dts+8).y
  ```

+ ```nasm
  mov SI, 8
  inc (dts[SI]).m
  ```

+ ```nasm
  lea BX, dt1
  mov [BX].d, 10
  ```

=== Замечания

+ ```
  type (dts[SI]).m = type(dts[SI].m) = 1
  ```

  но

  ```
  type dts[SI].m = type dts = 4
  ```

+ Если при описании типа в директиве, описывающей некоторое поле, указано несколько констант или
  конструкция повторения `DUB`, то при описании переменной такого типа это поле не может иметь
  начального значения (только пусто).

  Но если значением по-умолчанию является строка, то начальным значением этого поля может быть
  тоже строка такой же длины или меньшей. Если меньшей длины, то справа будут пробелы. Если больше,
  то будет сообщение об ошибке.

  *Например*, опишем структуру:

  ```nasm
  student struc
    f DB 10 DUP (?)     ; Фамилия
    i DB "*******"      ; Имя
    gr DW ?             ; Группа
    oz DB 5, 5, 5       ; Оценки
  student ends
  ```

  Теперь создадим переменную:

  ```nasm
  st1 student <"Petrov", >       ; Нельзя, так как значение по-умолчанию не строка
  st2 student <, "Petr", 112, >  ; Можно, f не имеет начального значения
  st3 student <, "Alexandra">    ; Нельзя, в поле i - 10 элементов, а максимально 7
  ```

== Пример программ с использованием данных структурного типа

=== Первый пример

```nasm
.model tiny
.code
org 100h

start:
  mov AH, 9
  mov DX, offset message
  int 21h

  lea DX, st1.s
  int 21h

  lea DX, st1.f
  int 21h

  lea DX, st1.i
  int 21h

  ret

message DB "hello", 0dh, 0ah, '$'

tst struc
  s DB "student", '$'
  f DB "Ivanov", '$'
  i DB "Ivan", '$'
tst ends

st1 tst <>
```

=== Второй пример

```nasm
start:
  mov AH, 9
  mov DX, offset message
  int 21h

  mov SI, 0
  mov CX, 3
  m1:
    ; Адресация прямая с индексированием. С полями структуры работаем,
    ; как с элементами массива.
    lea DX, st1[SI]
    int 21h
    add SI, 9
    loop m1
    ret

message DB "hello", 0dh, 0ah, '$'

tst struc
  s DB "student ", '$'
  f DB "Ivanov  ", '$'
  i DB "Ivan    ", '$'
tst ends

st1 tst <>

ends
```

=== Третий пример

```nasm
start:
  mov AH, 9
  mov DX, offset message
  int 21h

  lea BX, st1
  mov CX, 2             ; кол-во повторений внешнего цикла

  m2:
    push CX
    mov SI, 0
    mov CX, 3           ; кол-во повторений внутреннего цикла

    m1:
      push CX
      lea DX, [BX][SI]  ; адресация по базе с индексированием
      int 21h
      add SI, 9
      pop CX
      loop m1

    add BX, type tst    ; переход к следующей записи
    pop CX              ; восстанавливаем кол-во повторений внешнего цикла
    loop m2

  ret

message BD, "hello", 0dh, 0ah, '$'

tst struc
  s DB ?
  f DB ?
  i DB ?
tst ends

st1 tst <"student$", "Ivanov $", "Ivan   $">
st2 tst <"student$", "Petrov $", "Petr   $">

end start
```

= Записи в Ассемблере

*Записи* --- это упакованные данные, которые занимают неполные ячейки --- байты --- а части памяти
(части байта или части слова, например).

- В отличие от записей, в структуре поле может занимать строго байт или слово.

- Записи --- это последовательности битов, при чём поля прижаты к друг другу, между
  ними нет пробелов, размер поля в битах.

- Разряд может быть любым, но сумма размеров полей не должна привышать 8 или 16.

- Сумма размеров полей --- это размер записи.

- Если размер записи меньше 8 или меньше 16, то они прижимаются к правой границе байта или слова,
  левые лишние разряды заполняются нулями и никак не влияют на работу записи.

- Каждое поле, как и в структуре, имеет собственное имя, но обращаться к полю по имени *нельзя*,
  так как наименьшая адресуемая ячейка для процессора --- байт.

- Также, как и для структуры, чтобы работать с записью, нужно создать идентификатор типа записи
  (то есть описать его тип), а затем переменную такого типа.

- Описания типа может быть в любом месте, но до описания переменных этого типа (как у структур).

- *Синтаксис создания записи*

  ```
  <имя типа> record <поле>[, <поле>]
  ```

  где поле, это

  ```
  <имя поля>:<размер>[ = <выражение>]
  ```

  Выражение определяет значение поля. Знак вопроса не допускается. Если выражение
  отсутствует, значение по-умолчанию будет нулём.

  ```nasm
  TRec record A:3, B:3 = 7    ; 3 + 3 = 6      <= 8  => запись занимает байт
  TDate record Y:7, M:4, D:5  ; 7 + 4 + 5 = 16 <= 16 => запись занимает слово
  ```

- *Описание переменных*

  ```
  record имя типа <начальные значения>
  ```

  Начальными значениями могут быть
  + Константные выражения
  + Знак вопроса
  + Пусто

  В отличие от структуры знак вопроса определяет нулевое значение.

  ```nasm
  Rec1 TRec <3, >
  Rec2 TRec <, ?>
  Dat1 TDate <80, 7, 4>
  ```

  Также, как и для структур, в некоторых случаях можно не писать запятые.

- *Массив записей*

  MDat TDate 100 DUP (<>)

- Нельзя работать с полями отдельно, как с байтами или словами. Но можно работать
  с записями целиком, как с байтами и словами.

- Можно присвоить значение одной записи полям другой записи.

  ```nasm
  ; Из памяти в память MOV делать нельзя, используем промежуточный регистр
  mov AL, Rec2
  mov Rec1, AL
  ```
