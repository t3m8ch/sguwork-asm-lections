= Структура программы

Язык ассемблера -- это машинно-ориентированный язык
программирования, где каждое высказывание соответствует одной
команде процессора.

Программа ассемблер -- преобразует исходный код в коды команд
процессора.

Операторы -- инструкции, управляющие работой процессора.

Директивы -- инструкции, указывающие программе ассемблеру,
каким образом следует объединять инструкции для создания модуля,
который и станет работающей программой.

Инструкция процессора:
`[[метка:]] мнемоника [[операнды]  [[;комментарии]]`.

Переменная -- метка или символическое имя, связанная с конкретной
областью памяти, предназначенной для хранения данных.

Для определения переменной используются директивы `DB` (define
byte), `DW` (define word), `DD` (define double word), `DS` (define
segment) и так далее.

Пример:

```
Hello db 'Hello, World!$'
```

= Организация программы

+ Программа на Ассемблере состоит из различных модулей, каждый из
  которых располагается в отдельном файле.
+ Модуль в свою очередь состоит из инструкций процессора и директив,
  каждый модуль оканчивается директивой `END`.
+ Метка, стоящая после кода псевдооперации `END` указывает на
  адрес, с которого должна начинаться программа, и называется
  точкой входа в программу.
+ Каждый модуль разбивается на отдельные части директивами
  сегментации, которые определяют начало и конец сегмента. Каждый
  сегмент начинается директивой начала сегмента `SEGMENT`, и
  оканчивается директивой конца сегмента `ENDS`. В начале директив
  ставится имя сегмента.

При загрузке программы в ОЗУ DOS создаёт как минимум три сегментных
регистра: `CS`, `DS`, `SS`. При этом код программы и данные,
представленные в виде байтов, копируются с диска в ОЗУ. Адреса
сегментов записываются в регистры `CS`, `DS` соответственно.

Сегмент стека же либо аллоцируется в указанном в программе месте,
либо аллоцируется (если явно не указано) с самым первым сегментом
программы. Адрес сегмента стека записывается в регистр `SS`.

Дополнительные сегментный регистр ES как правило используется для
обращения к памяти, которые не входят в программу, например, к
видеопамяти или системным ячейкам. Однако при необходимости в него
можно поместить какой-либо сегмент.

Все сегменты могут располагаться в разных областях памяти, а могут
и пересекаться либо частично, либо полностью.

#image("images/3.GIF")

Обращение к ячейкам программы осуществляется с помощью указания
сегмента и номера байта внутри сегмента (этот номер носит название
относительного адреса или смещения).

#image("images/4.GIF")

Для определения адреса начала сегмента необходимо умножить
содержимое сегментного регистра на 16 (экивалентно сдвигу на
4 бита влево).

При записи команд на языке ассемблера принято указывать адреса
с помощью следующей конструкции:

`<адрес сегмента>:<смещение>` или
`<сегментный регистр>:<адресное выражение>`

Например, запись DS:DX означает, что адрес ячейки складывается
из адреса начала сегмента, хранящегося в регистре DS, и смещения
внутри сегмента, записанного в DX.

= Директива `ASSUME`

Программа ассемблер должна заранее знать, через какие регистры
должны адресовываться ячейки программы. Для этого используется
директива `ASSUME`.

С помощью этой директивы ассемблеру сообщается информация о
соответствии между сегментными регистрами и программными сегментами.
Директива имеет следующий формат:

`ASSUME <пара>[[, <пара>]]` \
`ASSUME NOTHING` \

где `<пара>` - это `<сегментный регистр>` :`<имя сегмента>`

либо `<сегментный регистр>:NOTHING`

Например, директива `ASSUME ES:A, DS:B, CS:C` сообщает ассемблеру,
что для сегментирования адресов из сегмента А выбирается регистр ES,
для адресов из сегмента В –- регистр DS, а для адресов из сегмента
С –- регистр CS.

Регистр может указывать только на один сегмент, но на один сегмент
могут ссылаться несколько регистров.

Если регистр не должен указывать на какой-либо сегмент, пишут
что-то вроде `ES:NOTHING`.

Выполнение программы необходимо начать с команд, которые установят
необходимые значения для сегментных регистров. По-умолчанию,
DS и ES указывают на префикс программного сегмента (Program
Segment Prefix -- PSP). PSP может использоваться в программе для
определения имён файлов, параметров командной строки, объёма
доступной памяти, переменных окружения и т.д.

Процессор не может напрямую передать имя сегмента в сегментный
регистр, поэтому воспользуемся регистром AX в качестве посредника:

```
MOV АХ, В
MOV DS, AX
```

Аналогично можно сделать и для ES.

Регистр CS загружать вручную не надо, этим занимается ОС.

Регистр SS можно установить как вручную, так и поручив эту задачу
ОС, описав сегмент стека с помощью ключевого слова `STACK`.

= EXE и COM программы

DOS может загружать и выполнять программы двух типов: EXE и COM.
Ввиду сегментации программных сегментов, включая сегменты кода,
данных и стека оба типа программ могут выполняться в любом месте
в памяти.

Программы никогда не пишутся из предположения, что они будут
загружаться с определённого адреса в памяти (за исключением
некоторых самозагружающихся и защищённых от копирования программ).

EXE-программы содержат несколько программных сегментов, включая
сегмент кода, данных и стека. EXE-файл загружается с адреса
PSP:0100h. В процессе загрузки считывается информация из
EXE-заголовка в начале файла, при помощи которого загрузчик
выполняет настройку ссылок на сегменты в загруженном модуле, чтобы
учесть тот факт, что программа была загружена в произвольно
выбранный сегмент. После настройки ссылок управление передаётся
загрузочному модулю к адресу CS:IP, извлечённому из заголовка
EXE.

COM-программы содержат единственный сегмент (или, во всяком случае,
не содержат явных ссылок на другие сегменты). Образ COM-файла
считывается с диска и помещается в ОЗУ, начиная с адреса PSP:0100h.
Поэтому программа должна в начале содержать директиву, позволяющую
осуществить такую загрузку: `ORG 100h`.

#image("images/5.GIF")

COM-программы предпочтительнее для небольших ассемблерных утилит,
поскольку они быстрее загружаются, ибо не требуется перемещения
сегментов, а также они меньше занимают места на диске, так как
EXE-заголовок и сегмент стека отсутствуют в загрузочном модуле.

= Примеры программ

Пример 1:

```
stak segment stack 'stack'      ;Начало сегмента стека
db 256 dup (?)                  ;Резервируем 256 байт для стека
stak ends                       ;Конец сегмента стека
data segment 'data'             ;Начало сегмента данных
Hello db 'Hello, World!$'       ;Строка для вывода
data ends                       ;Конец сегмента данных
code segment 'code'             ;Начало сегмента кода
assume CS:code,DS:data,SS:stak  ;Сегментный регистр CS будет указывать на сегмент команд,
                                ;регистр DS - на сегмент данных, SS – на стек
start:                          ;Точка входа в программу start
;Обязательная инициализация регистра DS в начале программы
mov AX,data                     ;Адрес сегмента данных сначала загрузим в AX,
mov DS,AX                       ;а затем перенесем из AX в DS
mov AH,09h                      ;Функция DOS 9h вывода на экран
mov DX,offset Hello             ;Адрес начала строки 'Hello, World!' записывается в регистр DX
int 21h                         ;Вызов функции DOS
mov AX,4C00h                    ;Функция 4Ch завершения программы с кодом возврата 0
int 21h                         ;Вызов функции DOS
code ends                       ;Конец сегмента кода
end start                       ;Конец текста программы с точкой входа
```

В общем случае сегменты могут располагаться, как угодно, но
рекомендуется сегмент кода ставить в конце для быстродействия.

Вывод на экран будет производится при помощи вызова стандартных
процедур DOS, которые называются прерывания. Прерывания DOS под
номером 21h (33) называются функциями DOS. Номер прерывания и
параметры передаются в регистрах. Номер должен находиться в
регистре AH. Например для вывода на экран в AH нужно поместить
число 9, а в DX -- адрес строки символов, которая оканчивается
знаком `$`.

Адрес строки записывается при помощи команды `OFFSET`:

```
OFFSET имя
```

Значением оператора является смещение указанного имени, отсчитанное
от начала того сегмента, в котором оно находится. Именем может
быть переменная или метка (именем команды).

При трансляции ассемблер ставит в соответствие имени переменной
Hello, описанной в директиве DB, смещение первого байта строки
Hello относительно начала сегмента DS. С помощью OFFSET мы
записываем это смещение в регистр DX:

```
mov dx, OFFSET Hello
```

Выход из программы происходит при помощи функции DOS с номером
`4Ch`. Данная функция смотрит в регистр AL код завершения программы,
который будет передан DOS'у. При успешном выполнении код заверешния
равен 0.

== Модели памяти

Модель памяти задаётся директивой `.MODEL`, после установки которой
вступают в силу упрощённые директивы определения сегментов,
объединяющие действия директив `SEGMENT` и `ASSUME`. Кроме того,
такие сегменты не надо закрывать при помщи директивы `ENDS` --
она закрываются автоматически при обнаружении директивы нового
сегмента.

Пример с использование памяти `SMALL` в EXE-программах:

```
.model small                 ;Модель памяти SMALL использует сегменты
                             ;размером не более 64Кб
.stack 100h                  ;Сегмент стека размером 100h (256 байт)
.data                        ;Начало сегмента данных
Hello db 'Hello, World!$'
.code                        ;Начало сегмента кода
start:                       ;Точка входа в программу start
                             ;Предопределенная метка @data обозначает
                             ;адрес сегмента данных в момент запуска программы,
mov AX, @data                ;который сначала загрузим в AX,
mov DS,AX                    ;а затем перенесем из AX в DS
mov AH,09h
mov DX,offset Hello
int 21h
mov AX,4C00h
int 21h
end start
```

В COM-программах, в отличие от EXE, используется лишь один сегмент,
используемый и для данных, и для кода, и для стека.

Пример с использованием памяти `TINY` в COM-программах:

```
.model tiny               ;Модель памяти TINY, в которой код, данные и стек
                          ;размещаются в одном и том же сегменте размером до 64Кб
.code                     ;Начало сегмента кода
org 100h                  ;Устанавливает значение программного счетчика в 100h
                          ;Начало необходимое для COM-программы,
                          ;которая загружается в память с адреса PSP:100h

start:
mov AH,09h
mov DX,offset Hello
int 21h
mov AX,4C00h
int 21h
;===== Data =====
Hello db 'Hello, World!$'
end start
```
