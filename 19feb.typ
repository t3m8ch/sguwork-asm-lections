= 64-разрядные процессоры

Для него добавляются регистры:
+ RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP -- расширенные регистры
+ R8, R9, R10, R11, R12, R13, R14, R15 -- новые регистры
+ RIP -- 64-битный указатель команд (в 32-битных процессорах так же
  есть EIP)
+ RFLAGS (EFLAGS для 32-битных процессоров)
+ Сегментные регистры (CS, DS, ES, FS, GS, SS) остаются 16-битными,
  но их использование в 64-битном процессоре ограничено.

= Оперативная память

ОЗУ состоит из байтов: каждый байт состоит из 8 информационных
разрядов. С 0 по 3 -- информационная часть, с 4 по 7 --
цифровая часть.

32 разрядный процессор может работать с ОП до 4 ГБ и, следовательно,
адреса байтов меняются от 0 до $2^32-1$.

Байты памяти могут объединяться в поля фиксированнной и переменной
длины.

Фиксированная длина -- слово (2 байта), двойное слово (4 байта).
Поля переменной длины могут содержать произвольное количество
байтов.

Адресным полем является адрес младшего входящего в поле байта.
Адрес поля может быть любой. Но в защищённом режиме должен быть
кратен 2 и 4 соответственно.

ОП может использоваться, как непрерывная последовательность байтов,
так и сегментированная последовательность байтов.

Если память сегментирована, то физический адрес байта состоит из
двух частей: сегмент:смещение, значение получается по формуле:
адрес сегмента + исполняемый адрес, при этом исполняемый адрес
формируется в команде различным способом в зависимости от способа
адресации операнда.

В защищённом режиме программа может определить и использовать
до 16383 сегментов, каждый размером до 4 ГБ. Таким образом,
программа может работать и использовать до 64 ТБ виртуальной
памяти. В реальном режиме адрес начала сегмента определяется
сегментным регистром, а для получения 20-разрядного двоичного
адреса к содержимому сегментного регистра, смещённому на 4 разряда
влево, прибавляется 16-рязрядное смещение и исполняемый адрес.

Как получается физический адрес следующей исполняемой программы?
+ ФА = (CS << 4) + IP
+ CS = 7A15 = 0111 1010 0001 0101
+ Смещаем: 0111 1010 0001 0101 0000
+ IP = C7D9 = 1100 0111 1101 1001
+ ФА = 1000 0110 1001 0010 1001

= Форматы данных

Рассматриваемый нами процессор может обрабатывать целые числа
без знака, целые числа со знаком, действительные с плавающей
точкой, двоично десятичные числа, символы, строки и указатели.

== Целые без знака

Целые без знака могут занимать байт, слово или двойное слово.
И принимать соответственно значения
+ В байте от 0 до 255
+ В слове от 0 до 65535
+ В двойном слове от 0 до 4294967295 ($2^32-1$)

При записи большего числа возникает ошибка.

== Числа со знаком

Числа со знаком могут занимать байт, слово или двойное слово.
Старший разряд (7, 15 или 31) -- это знак числа. Остальные --
цифры числа.

Принимают соответственно значения:
+ В байте от -128 до 127
+ В слове от -32768 до 32767
+ В двойном слове от -2147483648 до 2147483647

Дополнительный код положительного числа равен этому числу, а
дополнительный код отрицательного числа в любой системе счисления
можно получить по формуле $x = 10^n - |A|$, где A - само число.

Дополнительный код двоичного числа получить проще:
+ Инвертировать данное число
+ Прибавить единицу к младшему разряду

=== Вычитание в машине

В машине дополнительный код вычитаемого прибавляется к уменьшаемому.
Например 65 - 42 = 23:
+ 65 = 01000001
+ 42 = 00101010
+ Дополнительный код = 11110100
+ 01000001 + 11110100 = 23

== Числа с плавающей точкой

Могут занимать 32 разряда, 64 разряда или 80 разрядов. Называются
соответственно короткое вещественное, длинное вещественное и
рабочее вещественное.

Формат числа с плавающей точкой состоит из трёх полей:
+ Знак числа
+ Машинный порядок
+ Мантисса

В коротком вещественном числе ($-10^(+-32)...+10^(+-32)$):
+ Знак числа -- 1 бит
+ Машинный порядок -- 8 бит
+ Мантисса -- 23 бита

В длинном вещественном числе ($-10^(+-308)...+10^(+-308)$):
+ Знак числа -- 1 бит
+ Машинный порядок -- 11 бит
+ Мантисса -- 52 бита

В рабочем вещественном числе ($-10^(+-4932)...+10^(+-4932)$):
+ Знак числа -- 1 бит
+ Машинный порядок -- 15 бит
+ Мантисса -- 64 бита

Мантисса -- сколько цифр в числе. Диапозон определяется машинным
порядком.

Машинный порядок неявным образом включает в себя знак порядка
и связан с порядком истины такой формулой:
Пм = Пи + $127_10$($1023_10$ или $16383_10$)

Предполагается, что мантисса нормализована. Т.е. старший единичный
разряд мантисса не записывается в разрядную сетку.

Для короткого вещественного:
+ 31 разряд -- знак числа
+ 8 рязрядов (30-23) -- машинный порядок
+ 23 рязрядов (22-0) -- мантисса

Пример: 3060
+ Из 10 в 16 систему счисления: BF4
+ Нормализуем это число: 0.BF4 + $10^3$
+ Получаем машинный порядок: истинный порядок 3 + 127 десятичных
  (7F в шестнадцатеричной системе счисления), получим 82
  шестнадцатеричных
+ Запишем в разрядную сетку в двоичной системе счисления:
  0 1000 0010 011 1111 0100 0000 0000 0000
+ В шестнадцатеричной системе счисления: 413F4000

== Двоично десятичные числа

Процессором могут обрабатываться восьмиразрядные числа в
упакованном и в неупакованном формате. Сопроцессором могут
обрабатываться 80-разрядные упакованном формате.

Упакованный формат -- в байте хранится 2 цифры, в цифровой части
и информационной.

В неупакованном используется только цифровая часть байта.

== Символьные данные

Они хранятся в ASCII коде, каждому символу отводится 1 байт.
Это американский стандартный код для обмена информацией.

== Строковые данные

Это последовательности байтов, слов или двойных слов.

== Указатели

Длинный указатель -- 48 разрядов: 16 -- селектор (адрес сегмента)
и 32 -- смещение внутри сегмента.

Короткий указатель состоит только из одного смещения (32 разряда).

= Форматы команд

Команды вообще для процессора -- это цифровой двоичный код,
состоящий из двух подпоследовательностей, одна из них опрделяет
код операции (сравнить, умножить, разделить, переслать), а вторая
подпоследовательность определяет адресную часть (где взять данные,
участвующие в операции и куда отправить результат).

Наш процесор может работать с безадресными командами, где будет
только код операциц, одноадресными, двухадресными и трёхадресными
командами. И в памяти команда может занимать от 1 до 15 байт.

Данные, участвующие в операции, могут находится непосредственно
в команде, могут находится в регистре, в памяти. Наибольшее
количество команд двухадресные.

Операнд может быть размером байт, слова или двойного слова.

Исполняемый адрес в общем случае может состоять из трёх частей:
+ из базы,
+ индекса
+ и смещения

Существуют различные способы реализации:
+ Регистровая
+ Непосредственная
+ Прямая
+ Косвенная-регистровая
+ По базе со смещением
+ Прямая с индексированием
+ По базе с индексированием

=== Примеры команд с различной адресацией операндов

В командах в Ассемблере результат всегда пересылается по адресу
первого операцнда.

1) Регистрация

`MOV AX, BX`: (BX) -> AX
Машинный формат: 1001 0011 1100 0011
"код операции": 1000100
"d" = 1
"w" = 1
"mod" = 11
"reg" = 000
"r/m" = 011

2) Непосредственная

`MOV AX, 25`: 25 -> AX
`CONST EQU 34h`: именнованная константа
`MOV AX, CONST`: 34h -> AX

3) Прямая

Если известен адрес памяти, то мы можем непосредственно указать
этот адрес:

`MOV AX, ES` : 0001

+ ES -- регистр сегмента данных,
+ 0001 -- смещение внутри сегмента

((ES) + 0001) -> AX

Прямая адресация может быть записана с помощью символического
имени, которое предварительно поставлено в соответствие некоторому
адресу памяти, с помощью специальной директивы определения памяти.

Например:
+ DB -- байт
+ DW -- слово
+ DD -- двойное слово

Если в сегменте ES содержится директива `Var p DW 7`, тогда по
команде `MOV AX, ES : Var p   ; ((ES) + Var p) -> AX`

Например, если команда имеет вид:
`MOV AX, Var_p   ; ((DS) + Var_p) -> AX`

== Косвенно-регистровая адресация

Отличается от регистровой тем, что в регистре теперь содержится
не сам операнд, а адрес области памяти, в которой содержится
операнд. А в записи мы берём регистр в квадратных скобках:

`MOV AX, [SI]`

== По базе со смещением

`MOV AX, [BX] + 2` аналогично `MOV AX, [BX + 2]`, аналогично
`MOV AX, 2[BX]`. Результат будет `((DS) + (BX) + 2) -> AX`.

При `MOV AX, [BP + 4]` будет `((SS) + (BP) + 4) -> AX`

Для работы с одномерными массивами, для работы с полями структур
