`int` --- прерывает работу процессора и передаёт управление
ОС или BIOS, после выполнения некоторой системной обрабатывающей
программы управление возвращается к команде, следующей за `int`.

Какая системная программа будет выполняться, зависит от операндов
в команде `int` и от значений некоторых регистров.

Для вывода символа в `AH` загружаем 6, а в `DL` --- символ.
После этого мы выполняем `int 21h`.

Стек работает при помощи `SS`, `SP` и `BP`. Адрес начала сегмента ОС
сама загружает в регистр `SS`.

Добавление в стек происходит при помощи команды `PUSH <операнд>`, 
операндом которой может быть регистр или память, и при добавлении
в стек содержимое регистра `SP` уменьшается на размер операнда.

Для взятия/удаления из стека используется команда `POP <операнд>`.

Командами `PUSHA` и `POPA` загружается/удаляется из стека соответственно
содержимое регистров общего назначения последовательности `AX`, `BX`, `CX`, `DX`, `SP`, `BP`, `SI`, `DI`.

С помощью команд `PUSHAD` и `POPAD` в такой же последовательности
загружаются/удаляется 32-битные регистры общего назначения.

Чтобы не удалять из стека, а использовать данные, расположенные
в стеке, нужно использовать регистр `BP`, загрузив в него предварительно
содержимое регистра `SP`: `MOV BP, SP` загружает содержимое
`SP` в `BP`. `MOV AX, [BP+6]` -- загружаем содержимое двух байтов
памяти, начиная с адреса (SS:(BP+6)) -> AX. Число 6 или другое
определяет программист, где по отношению к вершине стека находятся
данные, которые программист хочет использовать.

*Пример:* необходимо переслать из одной области памяти в другую
в обратной последовательности данные и вывести их на экран. С помощью
директив стандартной сегментации.

Директивы

```
TITLE Prim.asm
PAGE ,120

; Описание сегмента стека
SSeg Segment Para stack `stack`
  DB 100h DUP (?) ; 256 байт под стек
SSeg ends

; Описание сегмента данных
DSeg Segment Para Public `Data`
  DAN DB `1`, `3`, `5`, `7`
  REZ DB 4 DUP (?)
DSeg ends

; Кодовый сгемент оформлен как одна внешняя процедура, к
; ней обращаются из отладчика
CSeg Segment Para Public `Code`
  ASSUME SS:SSeg, DS:DSeg, CS:CSeg
  Start Proc FAR
    PUSH DS      ; сохраняем в стеке значение сегмента данных
    XOR AX, AX   ; делаем AX пустым
    PUSH AX      ; сохраняем в стеке адрес, откуда мы пришли и пустое слово
    MOV AX, DSeg 
    MOV DS, AX   ; загружаем адрес нашего сегмента данных в сегмент регистра DS

    ; пересылка данных в обратной последовательности с
    ; выводом на экран
    MOV AH, 6
    MOV DL, DAN + 3   ; записали 7
    MOV REZ, DL
    INT 21h
    MOV DL, DAN + 2   ; записали 5
    MOV REZ + 1, DL
    INT 21h
    MOV DL, DAN + 1   ; записали 3
    MOV REZ + 2, DL
    INT 21h
    MOV DL, DAN       ; записали 1
    MOV REZ + 3, DL
    INT 21h

    MOV AH, 4CH
    INT 21h
  Start endp
CSeg ends
end Start

; Директива TITLE и PAGE
```

`TITLE` --- позволяет сделать заголовок листинга (до 60 символов). \
`PAGE <кол-во строк> <кол-во столбцов>` --- устанавливает количество 
строк на странице листинга и количество символов в строке. По-умолчанию
на странице листинга 80 строк. Эта директива может использоваться
без параметров, может быть записана в любом месте программы и она
осуществит переход на следующую страницу листинга.

= Директива сегмента

`<имя> Segment <ReadOnly> <выравнивание> <тип> <размер>`

Может иметь 5 параметром (каждый из них может отсутствовать):
+ *имя*
+ *ReadOnly* --- если он есть, приведёт к сообщению об ошибке
  при попытке записи в этот сегмент
+ *выравнивание* --- определяет, каким должен быть адрес начала
  сегмента, значения:
  + `BYTE` --- адрес сегмента может быть любым
  + `WORD` --- адрес сегмента должен быть кратным нулю 2
  + `DWORD` --- адрес сегмента должен быть кратным нулю 4
  + `Para` --- адрес начала сегмента кратен 16
  + `Page` --- адрес начала сегмента кратен 256

  Если не указано, то по-умолчанию адрес сегмента должен быть
  кратен 16.
+ *тип* --- определяет способ объединения сегментов, значения:
  + `stack` --- для сегмента стека
  + `Public` --- для остальных сегментов, все сегменты с одним
    именем и разными классами объединяются в один сегмент в той
    последовательности, в которой они записаны
  + `Common` --- скажет Ассемблеру, что такие сегменты с
    одним именем и разными классами тоже объединяются, но не
    последовательно, а начиная с одного и того же адреса.
    Размер будет не суммой размеров всех сегментов, а размера
    максимального сегмента.
  + `IT <выражение>` --- сегмент располагает строго по указанному
    адресу, определяемому этим выражением. 
  + `Private` --- сегмент ни с кем не должен объединяться.
+ *разрядность*
  + `use 16` --- сегмент до 64 КБ
  + `use 32` --- сегмент до 4 ГБ
+ *класс* --- сегменты с одинаковым классом будут располагаться
  в исполняемом файле последовательно друг за другом так же,
  как и в написании.

Ассемблер позволяет программировать с упрощённой системой
сегментации при помощи упрощённых директив. Первая из них ---
директива `MODEL`, которая определяет модель памяти, которая
будет использовать программа. Параметр у этой директивы один.
Возможные значения:
+ `TINY` --- программа располагается в одном сегменте
+ `SMALL` --- один сегмент под данные, один сегмент под код
+ `MEDIUM` --- один сегмент под данные, и много подпрограмм
+ `COMPACT` --- под программу один сегмент, под данные много сегементов
+ `LARGE` и `HUGE` --- и под данные, и под программу много сегментов,
  последний параметр у `HUGE` определяет, можно ли использовать
  больше памяти, чем у ОЗУ (виртуальная памяти на диске).

Вариант программы с `SMALL`.

```
.MODEL SMALL

.STACK 100h

.DATA
St1 DB 'Line 1', '$'
St2 DB 'Line 2', '$'
St3 DB 'Line 3', '$'

.CODE
begin:
  MOV AX, @DATA
  MOV DS, AX
  MOV AH, 9
  MOV DX, OFFSET St1  ; или LEA DX, St1
  INT 21h
  MOV DX, OFFSET St2
  INT 21h
  MOV DX, OFFSET St3
  INT 21h
  MOV AX, 4C00h
  INT 21h
END begin
```

После выполнения программы на экране появится строка `Line1Line2Line3`.
Знак доллара определяет --- признак конца строки.

Для вывода каждой строки на отдельной строке:
```
St1 DB 'Line 1', 13, 10, '$'  ; перевод строки, возврат каретки
St1 DB 'Line 2', 0Dh, 0Ah '$'
St1 DB 'Line 3', '$'
```

= COM-файл

После второго этапа обработки программы Ассемблером мы получаем
EXE-файл, в котором присутствует блок начальной загрузки, размером
не менее 512 байт. Но существует другой формат исполняемого файла ---
COM-файл. У него этот блок отсутствует. А это значит, что одна и та же
программа, оформленная как EXE-файл или как COM-файл, будут весить 
по-разному: COM-файл будет занимать существенно меньше места. COM-файл
можно получить из EXE-файла с помощью системной обрабатывающей
программы `EXE2BIN.COM` или при помощи среды разработки.

Но из всякого EXE-файла можно получить COM-файл. Основные требования:
+ COM-файл всегда занимает только один сегмент памяти.
+ Поскольку ОС сама загружает адрес сегмента стека, о нём не нужно
  думать.
+ Данные и программа содержатся в одном сегменте.
+ Поскольку вся программа занимает один сегмент, то перед
  выполнением программы все сегментные регистры содержат адрес
  префикса программного сегмента `PSP`. Он есть и у EXE-файла,
  и у COM-файла. Этот префикс --- 256-байтный блок, который
  необходимо обойти, чтобы дальше выполнять программу. Чтобы его
  обойти, существует специальная директива `Org 100h`. Если
  программа записана с помощью стандартных директив сегментации,
  то `Org 100h` должна встать сразу директивой `ASSUME`.

*Пример создания COM-файла*:

```
TITLE Prog_Com-файл
PAGE 60, 85
CSeg Segment Para `Code`
  ASSUME SS:CSeg, DS:CSeg, CS:CSeg
  Org 100h
  Start:
    JMP Main
    St1 DB 'String1', 13, 10, '$'
    St2 DB 'String2', '$'
  Main Proc
    MOV AH, 9
    LEA DX, St1
    INT 21h
    LEA DX, St2
    INT 21h
    MOV AX, 4C00h
    INT 21h
  Main endp
CSeg ends
end Start
```

*Модель TINY*:

```
.MODEL TINY
.Code
  JMP Met
  St1 DB `String1`, '$'
Met:
  MOV AH, 09h
  LEA DX, St1
  INT 21h
  MOV AX, 4C00h
  INT 21h
end Met
```

Программист сам решает, где разместить данные: перед программом или
после программы.

```
Beg Proc
  MOV AH, 9
  LEA DX, St1
  INT 21h
  MOV AX, 4C00h
  INT 21h
Beg endp
St1 DB `String1`, '$'
end Beg
```

Небольшие программы на Ассемблере рекомендуется писать, как
COM-файлы, не забывая, что если он так написан, то как EXE-файл
его уже нельзя выполнить.

= Арифметические операции

== Безнаковые числа

Сложение и вычитание *безнаковых чисел* выполняется по правилам
аналогичным правилам, принятым в математике, как сложение и
вычитание по модулю $2^k$. Но в информатике k+1 разряд, если
он появляется, не выбрасывается, а записывается в флаг `CF` ---
флаг переноса.

+ `X + Y = (X + Y) mod 2^k` --- `X + Y и CF = 0`, если `X + Y` < $2^k$
+ `X + Y = (X + Y) mod 2^k` --- `X + Y = -2^k и CF = 1`, 
  если `X + Y` >= $2^k$

Если мы работаем с байтами:
250 + 10 = (250 + 10) mod $2^k$ = 260 mod 256 = 4\

*Вычитание*:
+ `X - Y = (X - Y) mod 2^k` --- `X - Y и CF = 0`, если `X >= Y`
+ `X - Y = (X - Y) mod 2^k` --- `X + 2^k - Y и CF = 1`, если `X < Y`

1 - 2 = 1 + $2^8$ - 2 = 257 - 2 = 255, CF = 1

== Знаковые числа

Сложение и вычитание знаковых чисел сводится к сложению и вычитанию
с дополнительным кодом.

$X = 10^n - |X|$

-1 = 256 - 1 = 255 = $1111 1111_2$ \
-3 = 256 - 3 = 253 = $1111 1101_2$ \
3 + (-1) = (3 + (-1)) mod 256 = (3 + 255) mod 256 = 2 \
1 + (-3) = (1 + (-3)) mod 256 = 254 = $1111 1110_2$ \

Программист сам должен помнить, со знаковыми он работает или
с безнаковыми. Он смотрит на флаги `CF` и `OF`. 

Арифметические операции влияет на флаги.

== Ассемблерные команды

+ *Сложение*
  
  + `ADD OP1, OP2` --- OP1 + OP2 -> OP1 
  + `ADC OP1, OP2` --- OP1 + OP2 + CF -> OP1
  + `XADD OP1, OP2` --- i486-процессоры, сначала меняет местами OP1
    и OP2, а потом складывает, сохраняя результат в OP1 (чтобы
    сохранить значение OP1) 
  + `INC OP1` --- OP1 + 1 -> OP1

+ *Вычитание*

  + `SUB OP1, OP2` --- OP1 - OP2 -> OP1
  + `SBB OP1, OP2` --- OP1 - OP2 - CF -> OP1
  + `DEC OP1` --- OP1 - 1 -> OP1

*Примеры:*

X = 1234AB12h \
Y = 5678CD34h \
X + Y = ...

Складываем без использования 32-битных регистров:

```
MOV AX 1234h
MOV BX 0AB12h
MOV CX 5678h
MOV DX, 0CD34h
ADD BX, DX
ADC AX, CX  ; Если CF изменился, нам нужно его учесть, поэтому ADC
```

Аналогично с вычитанием:

X - Y

```
SUB BX, DX
SUB AX, CX
```

В этих командах можно использовать различные способы адресации.

+ `ADD AX, max[SI]`
+ `SUB DX, max[BA][DI]`
+ `ADD CX, 32h`
