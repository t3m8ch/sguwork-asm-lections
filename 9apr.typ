= Записи

Для работы с отдельными полями существуют операторы:

- ```nasm width <имя поля записи>``` -- сколько битов занимает поле
- ```nasm width <имя записи или имя типа записи>``` -- сколько битов занимает вся запись
- ```nasm mask <имя поля записи>```
  ```nasm mask <имя записи или имя типа записи>```

  Результатом является маска (байт или слово), содержащая
  единицы в тех разрядах, которое занимает поле или запись в зависимости от операнда.

*Пример:*

Выявить родившихся 1-го числа, для этого придётся выделять поле D и сравнивать его значение
с 1-ым.

```nasm
m1:
  mov AX, Dat1
  and AX, mask D
  cmp AX, 1
  je yes
no:
  -----/-----
  jmp m1
yes:
  -----/-----
```

= Объединение (Union)

Это тип данных, который состоит из нескольких переменных, но хранятся они в памяти,
начиная с одного и того же адреса (перекрывая друг друга). Это используется для экономии
места памяти.

*Пример:*

Опишем типа данных ```nasm pdate record d:5, m:3, y:7=4```:

Далее опишем структуру:

```nasm
udate struc
  d db ?
  m db ?
  y dw 4
udate ends
```

Теперь объединяем в union:

```nasm
date union
  Dp pdate <>     ; 2 байта
  Du udate <>     ; 4 байта
  Z dw 3 dup (?)  ; 6 байт
date ends
```

Описываем переменную, обращаемся к её полям:

```nasm
MyDate date <>
mov AX, MyDate.Dp      ; 2 байта
and AX, Mask d         ; d - глобальное имя из записи pdate
mov AL, MyDate.Du.d
mov AX, MyDate.Z       ; AX := Z[0]
mov AX, sizeof MyDate  ; sizeof MyDate = 6
```

*TODO: перерисовать с фотографии табличку*

= Работа с подпрограммами в Ассемблере

Программа на Ассемблере оформляется, как процедура, к которой мы обращаемся из отладчика или из ОС,
и она в целом тоже завершается командой `ret`. Подпрограмма, как вспомогательный алгоритм,
в Ассемблере тоже оформляется, как процедура. Общий вид процедуры:

```nasm
<имя процедуры> proc <параметр>
  <тело процедуры>

  ret
<имя процедуры> endp
```

Такой шаблон может быть размещён в любом месте программы, но так, чтобы случайно на неё не
попадало управление. Поэтому подпрограммы обычно размещают или перед основной программой,
или после основной программы.

+ ```nasm
  cseg segment ...
    start:
      -----/-----
    finish:

    <подпрограмма 1>
    <подпрограмма 2>
    ...
    <подпрограмма N>
  cseg ends
  end start
  ```

+ ```nasm
  cseg segment ...
    <подпрограмма 1>
    <подпрограмма 2>
    ...
    <подпрограмма N>

    start:
      -----/-----
    finish:
  cseg ends
  end start
  ```

+ Если подпрограмм много, их размещают в другом кодовом сегменте.

== Замечания

+ После имени в директиве proc и endp двоеточие не ставится, но это имя считается меткой
  первой исполняемой команды процедуры.
+ Метки в процедурах не локализованы, поэтому они должны быть уникальны для всей программы.
+ Параметр в процедуре один: параметр `NEAR` может быть опущен, он используется по-умолчанию и
  значит, что это процедура ближнего типа вызова (то есть она размещена в том же кодовом
  сегменте, что и вызывающая программа); `FAR` говорит о том, что это процедура дальнего
  типа вызова и размещена в другом кодовом сегменте.

== Параметры процедуры

Основная проблема с подпрограммами в Ассемблере --- это передача параметров в подпрограмму
и возврат из неё результата.

*Способы передачи параметров*:

+ *По значению*

  При передаче параметров по значению процедуре передаётся значение фактического параметра,
  которое в процедуре копируется и используется, и поэтому изменить его значение невозможно.
  Такой способ используется для передачи небольшого количества параметров.

  *Например*, нужно вычислить значение `C = max(a, b) + max(7, a - 1)`. Все параметры
  имеют размер слова. Передадим их через регистры AX и BX. Результат возвращаем в AX.

  `AX = max(AX, BX)`

  ```nasm
  max proc
    cmp AX, BX
    jge met1
    mov AX, BX
  met1:
    ret
  max endp
  ```

  ```nasm
  ; c = max(a, b) + max(7, a-1)
  mov AX, a
  mov BX, b
  call max   ; AX = max(a, b)
  mov c, AX  ; c = max(a, b)
  mov AX, 7
  mov BX, a
  dec BX
  call max   ; AX = max(7, a-1)
  add c, AX  ; c = max(a, b) + max(7, a-1)
  ```

+ *По ссылке*

  Решим задачу. Вычислим `x = x div 16`.

  Если мы хотим обратиться несколько раз к процедуре, их адреса необходимо передавать
  в подпрограмму. Адреса можно передавать любым способом, в том числе и через регистры.
  Чаще всего используются регистры BX, DP, SI, DI. Будем передавать адрес через
  регистр BX.

  *Обращение к процедуре дважды:*

  ```nasm
  lea BX, a
  call Proc_dv
  -----/-----
  lea BX, b
  call Proc_db
  ```

  *Теперь опишем саму процедуру:*

  ```nasm
  Proc_dv proc
    push CX
    mov CL, 4
    shr word ptr [BX], CL  ; сдвиг работает намного быстрее, чем деление
    pop CX
    ret
  Proc_dv endp
  ```

  При входе в процедуру мы сохранили значение CX в стеке, потому что это значение возможно
  используется в вызывающей программе, поэтому при выходе мы восстановили его значение
  при помощи ```nasm pop CX```.

  Рекомендуется при входе в процедуру используемые в ней регистры сохранять в стеке, а перед
  выходом восстанавливать (кроме регистров, в которые записывается результат).

  ```nasm pusha``` и ```nasm popa``` сохраняют и достают 16-битные регистры. Для 32-битных
  есть ```nasm pushad``` и ```nasm popad```.

+ *По возвращаемому значению*
+ *По результату*
+ *По отложенным вычислениям*

*Паметры можно передать*:

+ *Через регистры (и по ссылке, и по значению)*

  Самый простой способ. В основной программе в регистр значение загружаем, в подпрограмме
  считываем. Такой способ используется при реализации функций DOS и BIOS.

+ *В глобальных переменных*

  Когда регистров не хватает, можно поместить параметры в сегмент данных. Но в этом случае
  нельзя будет реализовать рекурсию и даже иногда повторное обращение к подпрограмме.

+ *Через стек*

  Универсальный способ передачи параметров. Перед обращением к процедуре программист загружает
  в стек параметры (по значению или по ссылке), после входа в процедуру она извлекает данные из
  стека и использует. Такой способ используется в языках высокого уровня.

  Предположим, что подпрограмма имеет k параметров размером слово, и они сохраняются в стеке
  в последовательности слева направо. Тогда команды, реализующие обращение к подпрограмме,
  должны быть следующими

  ```nasm
  push a_1
  push a_2
  ...
  push a_k
  call PP
  ```

  Содержимое стека при входе в PP:

  ```
  SP -> a_v - адрес возврата
        a_k
        ...
        a_2
        a_1
  SS -> ...
  ```

  Но обращаться мы к параметрам можем с помощью регистра `BP`, но для этого мы ему должны присвоить
  значение `SP`. Если мы так сделаем, то мы затрём старое значение `BP`, которое возможно
  используется в вызывающей программе. Поэтому перед такой перессылкой нужно сохранить старое
  значение `BP` в стеке. Тогда входные действия в процедуре должны выглядеть так:

  ```nasm
  PP proc near
    push BP
    mov BP, SP
    ...
  ```

  Но стек у нас немного изменился:

  ```
  SP, BP -> BP_старое
      +2 -> a_v - возврата
      +4 -> a_k
            ...
            a_2
            a_1
            ...
  ```

  Для доступа к последнему параметру можно использовать выражение `[BP + 4]`.
  Например ```nasm mov AX, [BP + 4]```.

  После реализации вспомогательного алгоритма в процедуре должны следовать выходные действия,
  которые должны восстановить старые значения BP и очистить стек от параметров.

  ```nasm
  PP proc near
    ...
    pop BP
    ret 2*k  ; очистка стека от k параметров
  PP endp
  ```

  Команда `ret` в начале считывает адрес возврата, а затем удаляет из стека параметры.
  Можно удалить параметры и в основной программе:

  ```nasm
  ...
  call PP
  add SP, 2*k
  ...
  ```

  Можно использовать директиву `eq`, чтобы дать алиасы формулам `BP + 6`, `BP + 8` и так далее.

+ *В потоке кода*

  Заключается в том, что параметры размещаются сразу за командой `CALL`. И подпрограмма для того,
  чтобы их использовать, должна обратиться к адресу возврата, который записывается самой командой
  `CALL` в стек. Но для того, чтобы возратиться из процедуры, она должна изменить адрес возврата.

+ *В блоке параметров*

  Передача параметров через него --- это по сути передача массива глобальных величин. Блок
  параметров --- это участок памяти в сегменте данных, адрес которого передаётся в подпрограмму.
  Подпрограмма получает этот адрес любым из выше названных способов, после чего использует
  в подпрограмме.

  Такой способ используется, например, в реализации функций DOS и BIOS при работе с файлами
  (поиск файлов, загрузка и исполнение программы).

  *Пример:*

  Даны 2 массива целых положительных чисел без знака:

  ```nasm
  X DB 100 dup (?)
  Y DB 50 dup (?)
  ```

  Мы хотим вычислить ` DL = max(X) + max(Y)`. Адрес будем передавать через BX, а результат
  сохраним в AL. Через CX передадим кол-во элементов массива.

  ```nasm
  lea BX, X
  mov CX, 100
  call max      ; AL = max(X)
  mov DL, AL    ; DL = max(X)
  lea BX, Y
  mov CX, 50
  call max      ; AL = max(Y)
  add DL, AL
  ```

  Теперь опишем саму процедуру:

  ```nasm
  max proc
    push CX
    push BX
    mov AL, 0
  met1:
    cmp [BX], AL
    jle met2
    mov AL, [BX]
  met2:
    inc BX
    loop met1
    pop BX
    pop CX
    ret
  max endp
  ```
