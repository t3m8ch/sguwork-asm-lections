= Арифметические операции

*Пример 1*

```
MOV AL, 95h
ADD AL, 82h
```

95h + 82h = 117h \
95 = 10010101 \
82 = 100000010 \
10010101 + 100000010 = 1 0001 0111 \
CF = 1, OF = 1, SF = 0, ZF = 0, AF = 0, PF = 1

*Пример 2*

```
MOV AL, 9h
SUB AL, 5h
```

9h - 5h = 4h \
5 = 00000101 \
-5 = 11111011 \
9 + (-5) = 11111011 + 00001001 = 1 0000 0100 \
CF = 1, OF = 0, SF = 0, ZF = 0, AF = 1, PF = 0

== Умножение и деление

+ Умножение безнаковых чисел: `MUL OP2`

  (OP2) \* ((AL) или (AX) или (EAX)) -> (AX или DX:AX или EDX:EAX)

  Пример: `MOV BL` AX = AL \* BL \
  `MUL AX` DX:AX = AX \* AX

+ Умножение знаковых чисел: `IMUL OP2`

  Работает точно так же, как и с безнаковыми числами

+ Начиная с i386 есть двухадресная и трехадресная команды:

  ```
  MUL OP1, OP2
  MUL OP1, OP2, OP3 ; первый операнд всегда регистр,
                    ; второй операнд любой (данные, регистр или память)
                    ; третий операнд только данные
                    ; результат посылается в первый операнд
  ```

  При умножении результат может занимать удвоенный формат по отношению
  к операндам.

  Если программист точно знает, что результат умещается
  в формат операнда, то его можно извлекать из того, на что он нажал
  (AL, AX, EAX).

  Если не знаем, то можно спросить у флажков CF и OF.
  Если значения этих флажков равны единицы, то результат занимает
  удвоенный формат. Если равны нулю, то результат умещается в формат
  операнда.

  ```
  MUL CL            ; AX = AL * CL
  MUL BX, AX        ; BX = BX * AX
  MUL DX, BX, 134h  ; DX = BX * 134h

  IMUL SI           ; DX:AX = AX * SI
  IMUL CX, -5       ; CX * (-5)
  ```

+ Деление для безнаковый `DIV`, для знаковых `IDIV`

  `DIV OP2`
  `IDIV OP2`

  Операндом может быть регистр или память. Аналогично для знаковых чисел.

  В зависимости от типа и размера операнда, содержимое AX или DX:AX или EDX:EAX
  разделится на указанный операнд.

  Результат окажется в регистре AL или AX или EAX -- целая часть, остаток в
  AH, AX, EDX.

  Значения флажков не меняется, но может наступить момент деления на ноль или
  переполнение (частное больше, чем командой выделено ему места).

  ```
  MOV AX 600
  MOV BH 2
  DIV BH      ; 600 div 2 = 300 - не умещается в AL
  ```

  Пример:

  Цифры целого безнакового байтового числа N записать в байты памяти, начиная с адреса D
  как символы. N - (abc)

  ```
  ; c = N mod 10
  ; b = (N div 10) mod 10
  ; a = (N div 10) div 10

  N DB ?
  D DB 3 Dup (?)

  MOV BL, 10    ; делитель
  MOV AL, N     ; делимое
  MOV AH, 0     ; расширяем делимое до слова
  ; или CRW AH
  DIV BL        ; AL = ab, AH = c
  ADD AH, '0'
  MOV D+2, AH
  MOV AH, 0
  DIV BL        ; AL = a, AH = b
  ADD AL, '0'
  MOV D, AL
  ADD AH, '0'
  MOV D+1, AH
  ```

= Директивы внешних ссылок

Директивны внешних ссылок позволяют организовывать связь между
различными модулями и файлами, расположенными на диске.

+ `PUBLIC <имя> [, <имя>, ..., <имя>]`

  Определяет перечисленные имена, как глобальные, к котором
  можно обратиться из других модулей.

  Именами могут быть:
  + Имя меток
  + Имена переменных (в том числе определённых при помощи)

  Если в модуле A описано некоторое имя, как глобальное, и к нему
  нужно обратиться из модуля B и C, то в этих модулях B и C должна
  быть директива, определяющие эти имена, как внешние.

+ `EXTRN <имя>:<тип>, [<имя>:<тип>, ..., <имя>:<тип>]`

  Имя то же самое, что и в директиве PUBLIC. А тип определяется
  следующим образом:

  + Если именем была переменная, то типом может быть
    `BYTE`, `WORD`, `DWORD`, `QWORD` и т.д.
  + Если именем была метка, то типом может быть тип
    дальности `FAR` или `NEAR`.

  Пример:

  Модуль A:

  ```
  PUBLIC TODO
  ---/---
  TOT DW 0
  ```

  Нужно написать `EXTRN TOT:WORD`

  На этапе трансляции (ассемблирования) есть возможность подключить
  файл, расположенный на диске.

  ```
  INCLUDE <имя файла>
  ; например
  INCLUDE <C:\WORK\Prim.ASM>
  ```

  В результате ассемблирования на место этой директивы запишется
  содержимое файла `Prim.ASM`.

= Команды управления

Команды управления (команды передачи управления, организации цикло, условные,
безусловные) позволяют изменить ход вычислительного процесса.

+ Безусловная передача управления

  + `JMP <имя>`

    имя -- это метка команды, которая будет выполняться следующей за командой `JMP`.
    Причём команда с такой меткой может располагаться в этом же кодовом сегменте, что
    и команда `JMP`, а может быть и в другом кодовом сегменте; и тогда эта метка
    должна иметь тип `NEAR` или `FAR`.

    В сегменте, в который:

    ```
    PUBLIC M1
    ```

    В сегменте из которого:

    ```
    EXTRN M1:FAR
    ```

    Безусловную передачу управления можно осуществить при помощи прямой передачи или
    косвенной:

    ```
    JMP M1    ; прямая передача
    JMP [BX]  ; косвенная передача (в BX лежит адрес, куда мы передаём управление)
    ```

    JMP может занимать 3 байта, если это близкая передача, 5 байтов, если это дальняя
    передача (в другой сегмент). А можно сделать эту команду однобайтовой, если мы
    знаем, что передача осуществляется не более чем на -128 или на 127 байт, можно
    перед операндом написать `SHORT`:

    ```
    JMP Short M1
    ```

    После комнады `JMP` следующая команда должна иметь метку:

    ```
    ADD AX, BX
    JMP Short M1
    M2: ---/---
    -----/-----
    M1: ---/---
    ```

  + К командам безусловного перехода относятся команда обращения
    к подпрограмме и командам выходам выхода из неё.

    Процедуры имееют свойство `NEAR` или `FAR`. Если у нас
    есть головная программа и несколько подпрограмм, то головная
    всегда имеет тип `FAR`, а подпрограммы `NEAR`, если они
    содержатся в том же кодовом сегменте.

    Пример с одним и тем же сегментом:

    ```
    Cseg SEGMENT ...
      ASSUME ...

      p1 PROC far
        ...
        CALL p2
        ...
        RET
      p1 ENDP

      p2 PROC NEAR
        M2: MOV CX, DX
        ...
        RET
      p2 ENDP
    Cseg ENDS
    ```

    Пример с разными сегментами:

    ```
    EXTRN p2: FAR
    Cseg SEGMENT
      p1 PROC far
        ...
        CALL p2
        ...
        RET
      p1 ENDP
    Cseg ENDS
    ```

    ```
    PUBLIC p2
    Cseg1 SEGMENT
      ASSUME ...

      p2 PROC FAR
        ...
        RET
      p2 ENDP
    Cseg1 ENDS
    ```

    Обращение к процедуре: `CALL <имя>`.

    Адресация может быть и прямой, и косвенной. По этой команде в стек
    записывается адрес возврата (адрес команды, следующей за командой `CALL`).
    Затем управление передаётся указанной метке.

    Если управление передаётся процедуре ближнего типа вызова, то в стек
    записывается содержимое регистра `IP` или `EIP`. А если управление
    передаётся внешней процедуре (в другой кодовый сегмент), то в стеке
    сохраняется полный адрес возврата (адрес начала сегмента и его смещение
    `CS:<IP или EIP>`).

    `RET` -- тоже команда безусловной передачи управления. Осуществляет
    возврат к команде, следующей за командой `CALL`.

    Существует несколько вариантов:

    + `RET` -- может вернуться и из внешней процедуры, и из внутренней
    + `RETN [n]`
    + `RETF [n]`

    Параметр `n` может отсутствовать, а если он есть, то он говорит,
    какое кол-во байт нужно очистить перед выходом из процедуры.

  Пример прямого и косвенного перехода

  + ```
    a DW L  ; значением a является смещение для переменной L
    JMP L   ; прямой переход по адресу L
    JMP a   ; косвенный переход - goto (a) = goto L
    ```

  + ```
    MOV DX, a
    JMP DX  ; косвенный переход
    ```

  + ```
    JMP z   ; ошибка
    Z DW L
    ```

+ Условный переход
  В общем виде: `Jx`, вместо `x` -- от 1 до 3 букв, определяющих условие перехода.

  Эта метка может отстоять не дальше, чем на -128 и до 127.

  + Команды, используемые после команд сравнения
    + JZ/JNZ
    + JC/JNC
    + JO/JNO
    + JS/JNS
    + JP/JNP

  + Команды, используемые после команд, реагирующих на значения флажков

  + Команды, реагирующие на значение регистров CX

  *Примеры:*

  + `JE M1` -- после этой команды будет выполняться команда M1, если ZF = 1
  + `JNE M2` -- после этой команды будет выполняться команда M2, если ZF = 0
  + `JC M3` -- после этой команды будет выполняться команда M3, если CF = 1
  + `JNC M4` -- после этой команды будет выполняться команда M4, если CF = 0

  ```
  ADD AX, BX
  JC M
  ```

  CF = 1 => переход на M

  ```
  SUB AX, BX
  JZ Met
  ```

  В результате вычитания получилось 0 => ZF = 1 => переход на Met

  *Команда сравнения:*

  ```
  <метка> CMP OP1, OP2
  ```

  Результат никуда не посылается, вычитается из OP1 OP2, лишь меняются флажки.
  По флажкам переходми, куда нам надо.

  #table(
    table.header(
      [Условие], [Для безнаковых чисел], [Для знаковых чисел]
    ),
    [>], [JA], [JO],
    [=], [JE], [JE],
    [<], [JB], [JL],
    [>=], [JAE], [JGE],
    [<=], [JBE], [JLE],
    [<>], [JNE], [JNE]
  )

Поскольку условные команды передачи могут осуществлять только короткий переход,
то для реализации ближнего или дальнего перехода, необходимо с командой
условной передачи управления нужно использовать команды безусловной
передачи управления.

*Например:*

`Если AX = BX, то goto M`надо заменить на
```
Если AX = BX goto I
goto M
L: ...
```

```
CMP AX, BX
JNE L
JMP m
мет: ...
L: ...
```

С помощью команд условной и безусловной передачи управления можно реализовать
цикл с предусловием и цикл с постусловием:

+ С предусловием `while x > 0 do S`

  ```
  beg:
    cmp x, byte ptr 0
    jle fin
      S
    jmp beg
  fin:
    ...
  ```

+ С постусловием `do S while x > 0`:

  ```
  beg:
    S
    cmp x, byte ptr 0
    jg beg
  fin:
    ...
  ```

= Команды для организации циклов

В CX необходимо положить кол-во необходимых итераций.

+ `loop <метка>` -- По команде (CX) = (CX) - 1. Если после этого (CX) != 0,
  то переход на метку.

  *Пример:*

  ```
  MOV CX, 100
  m1:
    MOV AX, DX
    LOOP m1
  m2:
    ...
  ```

  Если CX нужен в теле цикла (например, дял работ со строками), то перед входом
  в цикл мы сохраним CX в стеке, а перед LOOP вытащим. Для итерации по массиву
  мы воспользуемся SI:

  ```
  MOV SI, 0
  MOV CX, 100
  m1:
    PUSH CX
    ...
    INC SI
    POP CX
    LOOP m1
  m2:
    ...
  ```

  Если у нас вложенные циклы, то мы тоже должны сохранять значение CX в стеке.

+ `loope <метка>` или `loopz <метка>` -- (CX) = (CX) - 1. Если после этого
  (CX) != 0 и одновременно ZF = 1, то переход на метку. Мы выходим из цикла,
  если (CX) = 0 или ZF = 0.

+ `loopne <метка>` или `loopnz <метка>` -- (CX) = (CX) - 1. Если после этого
  (CX) != 0 и одновременно ZF = 0, то переход на метку. Мы выходим из цикла,
  если (CX) = 0 или ZF = 1 или одновременно.
