= Директива equ

Она позволяет присвоить имена параметрам. Например:

```nasm
push x
push y
push z
call PP
-----/-----
PP proc near
  push BP
  mov BP, SP
  pp_x equ [BP + 8]
  pp_y equ [BP + 6]
  pp_z equ [BP + 4]
  -----/-----
  mov AX, PP pp_x  ; использование параметра x
  -----/-----
  pop BP
  ret 6            ; 6 - сколько байтов нужно удалить в стеке
PP endp
```

*Пример передачи параметров через стек*

Пусть процедура заполняет нулями массив A[0...n-1], а основная программа
дважды к этой процедуре обращается.

```nasm
zero_1 proc
  push BP
  mov BP, SP
  push BX
  push CX
  mov CX, [BP + 4]        ; CX = n
  mov BX, [BP + 6]        ; BX = A
  m1:                     ; цикл обнуления
    mov byte ptr [BX], 0
    inc BX
    loop m1
  pop CX
  pop BX
  pop BP
  ret 4
zero_1 endp
```

Фрагмент основной программы:

```nasm
X DB 100 dup (?)
Y DB 50 dup (?)
-----/-----
  ; загрузка параметров (адреса массива X и его размера в стек)
  lea AX, X
  push AX
  mov AX, 100
  push AX
  call zero_1

  lea AX, Y
  push AX
  mov AX, 50
  push AX
  call zero_1
-----/-----
```

= О передаче параметров в ПП

+ Передача параметров по значению

  ```nasm
  mov AX, word ptr value
  call PP
  ```

+ Передача по ссылке

  ```nasm
  mov AX, offset value
  call PP
  ```

+ *Передача параметров по возвращаемому значению*

  Объединяет передачу параметров по значению и по ссылке: процедуре передаётся адрес переменной,
  процедура делает локальную копию этого значения и работает с ней, а потом передаёт результат
  по указанному адресу.

+ *Передача параметров по результату*

  Передают адрес только для записи результата

+ *Передача параметров по имени макроопределения*

  ```nasm
  name macro parametr
    mov AX, parametr
  name endm
  ```

  Обращение к ПП может быть таким:

  ```nasm
  name value  ; обращение к макросу
  call PP     ; обращение к ПИ
  ```

+ *Передача параметров отложенным вычислением*

  Процедура получает адрес другой подпрограммы, которая вычисляет для неё параметры.

= Использование локальных параметров

Если локальных параметров немного, то их размещают в регистрах. Но если их много,
то можно использовать для них специальное место в сегменте данных, но тогда это место
будет занято постоянно, во-первых, а во-вторых, нельзя будет реализовать рекурсивные
подпрограммы, поэтому лучше использовать локальные параметры, размещённые в стеке.

Перед входом в подпрограмму выделяем место под локальные параметры, используем их в теле
процедуры, а перед выходом из процедуры удаляем из стека.

_Пример. Пусть в ПП будет три локальных параметра размером в слово. Тогда стек графически
можно представить так:_

```
-> SP      Lz
   BP - 4  Ly
   BP - 2  Lx
   BP      BP old
   BP + 2  av
   BP + 4  a_k
-----/-----
   a_1
-----/-----
   SS
```

При выходе из процедуры нужно вернуть прежнее значение SP. То есть если в стеке и фактические,
и локальные параметры, то шаблон подпрограммы с входными и выходными действиями будет выглядеть так:

```nasm
PP proc
  push BP
  mov BP, SP
  sub SP, k1  ; отвести в стеке k1 байтов под локальные параметры
  ; Сохраняем регистры, которые используются в подпрограмме
  push AX
  ...
  ; тело процедуры
  ...
  ; восстанавливаем регистры
  pop AX
  mov SP, BP  ; освободить место в стеке от локальных параметров
  pop BP
  ret k2      ; очистка стека от фактических параметров и возврат в вызывающую программу
PP endp
```

_Пример_

Рассмотрим строку, как массив символов. Начальный адрес передадим в подпрограмму через регистр
BX, длину строки через регистр CX, а результат запишем AX. В качестве результат мы хотим
видеть количество различных символов в заданой строке.

Используем процедуру, в которой выделим 256 байтов под локальный массив L по количеству
символов в строке, и будем k-му элементу массива присваивать единицу, если символ, цифровой
код которого равен k, в этой строке существует. Затем посчитаем количество единичек в
этой строке. Для начала массив очистим.

К первому элементу массива можно обратиться, как `L_1 = [BP - 256]`, а к k-му
`L_k = [BP - 256 + k]`. Напишем такую процедуру:

```nasm
count_s proc
  ; Входные действия
  push BP
  mov BP, SP
  sub SP, 256
  push BX
  push CX
  push SI

  ; Обнуление локального массива
  mov AX, CX  ; Сохранение длины исходной строки
  mov SI, 0   ; Индекс элемента массива
  m1:
    mov byte ptr [BP - 256 + SI], 0
    inc SI
    loop m1

  ; просмотр заданной строки и запись 1 в локальный массив
  mov CX, AX
  mov AX, 0
  m2:
    mov AL, [BX]                     ; код очередного символа в AL
    mov SI, AX                       ; пересылаем его в SI
    mov byte ptr [BP - 256 + SI], 1  ; пересылаем единицу в k-й элемент масива
    inc BX                           ; переход к следующему символу в строке
    loop m2

  ; подсчёт количества единиц в локальном массиве
  mov AX, 0
  mox CX, 256                        ; количество повторений цикла
  mov SI, 0                          ; индекс массива в SI
  m3:
    cmp byte ptr [BP - 256 + SI], 1
    jne m4                           ; если не равно единице, то на метку m4
    inc AX
  m4:
    inc SI
    loop m3

  ; выходные действия (регистр AX не трогаем,
  ; так как в нём хранится результат выполнения процедуры)
  pop SI
  pop CX
  pop BX
  mov SP, BP
  pop BP
  ret
count_s endp
```

= Рекурсия в Ассемблере

Основные трудности при реализации рекурсии в любом языке, в том числе и в Ассемблере,
--- это опасность зацикливания (зависания) и передача параметров.

Зависание не произойдёт, если в нашем алгоритме есть рекурсивная ветвь и нерекурсивная,
и при выполнении некоторого условия управление передаётся на нерекурсивную ветвь.

Сложность передачи параметров заключается в том, что их нельзя хранить в сегмента данных.
Для того, чтобы реализовать рекурсию, параметры нужно хранить в стеке.

_Пример рекурсивной фукнции: вычисление n-члена ряда Фибоначчи_

```nasm
Fib proc
  ; BX = f(n), AL = n
  cmp AL, 1
  ja m1
  ; нерекурсивная ветвь
  mov BX, 1  ; если n <= 1, то BX = 1
  ret
  ; рекурсивная ветвь
  m1:
    push AX
    dec AL      ; AL = n - 1
    call Fib    ; BX = f(n - 1)
    push BX     ; сохранить в стеке F(n - 1)
    dec AL      ; AL = n - 2
    call Fib    ; BX = f(n - 2)
    pop AX      ; AX = f(n - 1)
    add BX, AX  ; BX = f(n - 2) + f(n - 1)
    pop AX      ; восстановить AX
    ret
Fib endp
```

= Работа со строками

*Строка* --- это последовательность байтов, слов или двойных слов. Все команды для работы
со строками считают, что источник находится по адресу _DS:SI (DS:ESI)_, а строка --- приёмник ---
по адресу _ES:DI (ES:EDI)_.

Каждая команда работает с одним элементом строки: одним байтом, одним словом или двойным словом.
Это зависит от типа операнда. Чтобы выполнить действие со всей строкой, перед командой (слева
от команды) записывается специальный префикс --- команда повторить операцию, записанной справа
от неё. Префикс действует только на команды работы со строками.

Существуют следующие префиксы:
+ `rep <строковая команда>` --- повторять

  Заставляет повторяться указанную команду n-раз, где n содержится в регистре CX (ECX).
  Если CX = 0, то команда не выполнится ни разу.

  Используется с командами `movs`, `lods`, `stos`, `ins` и `outs`.

  Следующие 4 префикса --- с командами `cmps` и `scas`.

+ `repe <строковая команда>` --- повторять, пока равно

  Будет повторяться до тех пор, пока флаг ZF = 1, но не более чем n-раз (тоже хранится в CX/ECX).

  Псевдокод:
  ```nasm
  m:
    if (CX) = 0 then goto m1
    (CX) = (CX) - 1
    ; строковая команда
    if ZF = 1 then goto m
  m1:
  ...
  ```

+ `repz` --- повторять, пока ноль
+ `repne` --- повторять, пока не равно

  Работает до тех пор, пока флаг ZF = 0, но не более чем n-раз.
  Псевдокод:
  ```nasm
  m:
    if (CX) = 0 then goto m1
    (CX) = (CX) - 1
    ; строковая команда
    if ZF = 0 then goto m
  m1:
  ...
  ```

+ `repnz` --- повторять, пока не ноль

== Команды копирования для строк

+ `movs op1, op2` --- источник op2 = DS:SI (DS:ESI), приёмник op1 = ES:DI (ES:EDI)

  При использовании команды Ассемблер сам определяет по типу операндов в команде,
  что мы собираемся пересылать: байты, слова или двойные слова.

  В этой команде можно изменить DS на другой регистр: ES, GS, FS, CS, SS, но приёмник
  изменять нельзя.

  После выполнения команды содержимое регистров SI:DI увеличивается на один, два или
  четыре в зависимости от типа операнда, если флажок DF равен нулю. А если флажок DF равен
  единице, то содержимое этих регистров SI:DI автоматически уменьшается на 1, 2 или 4.

+ `movsb` --- байт данных из (DS:SI) пересылается в (ES:DI)
+ `movsw` --- слово данных из (DS:SI) пересылается в (ES:DI)
+ `movsd` --- двойное слово данных из (DS:SI) пересылается в (ES:DI)
