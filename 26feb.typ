= Особенности использования команды пересылки (mov)

+ Нельзя пересылать с помощью этой команды из одной области
  памяти в другую (если это необходимо, используют команды
  работы со строками)
+ Нельзя пересылать из одного сегментного регистра в другой
  (а если такая необходимость возникает, нужно воспользоваться
  или стеком, или другим регистром в качестве промежуточного)
+ Нельзя загружать сегментный регистр в непосредственно оператор
+ Нельзя загружать константы в сегментный регистр (нужно
  воспользоваться промежуточным регистром)
+ Нельзя командой MOV изменять содержимое регистра CS
+ Данные в памяти хранятся в перевёрнутом виде, а в регистрах --
  в нормальном виде. Команда MOV знает это и учитывает
  (`R DW 1234h` -- в байте с адресом R будет 34h, а в R + 1 будет
  12h; `MOV AX, R` -- 12h -> AH, 34h -> AL)
+ Размер передаваемых данных определяется типом опреандов в команде
  (`X DB ?` -- переменная X будет содержать адрес одного байта в
  памяти, `Y DW ?` -- переменная Y будет содержать поле в 2 байте
  в памяти, `MOV X, 0` -- очищение одного байта в памяти,
  `MOV Y, 0` -- очищение двух байтов в памяти, `MOV AX, 0` --
  очищение двухбайтового регистра, `MOV [SI], 0` -- сообщение об
  ошибке, нужно использовать специальный оператор PTR
  `<тип> PTR <выражение>`, если тип обоих операторов не определён,
  выражение может быть константным или адресным, а тип это `BYTE`,
  `WORD`, `DWORD` и так далее)
  ```
  MOV byte PTR [SI], 0
  ; = MOV [SI], byte PTR 0
  MOV [SI], word PTR 0
  ; 0 -> ((DS) + (SI))
  ```
+ Если типы операндов известны, то они должны соответствовать
  друг-другу.

  Например, `MOV AH, 500` -- нельзя\
  `MOV AX, X`, X мы определили, как байтовую величину,
  AX -- 2 байта \
  `MOV AL, R`, ошибка, R -- 2 байта, AL -- 1 байт\
  `MOV AL, byte PTR R` -- так можно (AL) = 34h \
  `MOV AL, byte PTR R + 1` -- (AL) = 12h

  К командам пересылки относят команду обмена значений операндов
  ```
  XCHG OP1, OP2  ; Синтаксис, r<->r or r<-> m
  MOV AX, 10h
  MOV BX, 20h
  XCHG AX, BX
  ```

  Для перестановки значений байтов внутри регистра используют
  команду `BSWOP`

  ```
  (EAX) -- 12345678h
  BSWOP EAX; (EAX) = 78563412h
  ```

К командам пересылки также относят
+ *Команды конвертирования*
  + `CBW` -- безадресная команда (AL) -> AX
  + `CWD` -- (AX) -> DX:AX
  + `CWE` -- (AX) -> EAX
  + `CDF` -- (EAX) -> EDX:EAX
+ *Команды условной пересылки CMOVxx*
  + `CMOVL AL, BL` -- если (AL) < (BL), то (BL) -> (AL)
+ *Загрзка адреса*
  + `LEA OP1, OP2` -- вычисляет адрес OP2 и пересылает первому
    операнду, который может быть только регистром
  + `LEA BX, M[BX][DI]`

= Структура программы на Ассемблере, формат команды и директивы

Программа на Ассемблере, так же как и на другом языке
программирования, проходит как минимум три этапа обработки:
+ На этапе *ассемблирования* один или несколько модулей на исходном
  языке преобразуется в машинные коды
+ На втором этапе *редактирования* эти модули объединяются в один
  загрузочный исполняемый модуль
+ На третьем этапе полученный *исполняемый модуль* может быть
  *выполнен*

  Исполняемых файлов может быть два типа:
  + *EXE-файлы*. Используется по-умолчанию.
  + *COM-файлы*. Если мы хотим его получить, то его получают на
    основе EXE-файла с помощью системно обрабатывающей программы
    EXE2BINCOM, или устанавливая в среде разработки специальный
    ключ.

`[<имя>][:][<операнды>][;комментарии]`

*Формат машинной команды* состоит из 4 полей:
+ *Поля имени*

  *Имя команды* -- символическое имя ассемблера, определяющее метку
  этой команды, позволяющее передать управление этой команде.

  Если после имени присутствует двоеточие, это значит, что метка
  является внутренний. Иначе -- внешняя.

+ *Поля операции (код операции)* -- единственное обязательное поле

  *Код операции* определяет, какое действие должен сделать
  процессор.

+ *Операнды*

  Их может быть один, два или три, разделены запятые. Определяют,
  где взять данные для выполнения операции и куда отправить
  результат.

+ *Комментарий*

Все поля разделяются хотя бы одним пробелом, а комментарии
начинаются ещё и точки запятой. Комментарий может занимать часть
строки или всю.

*Примеры*:
```
JMP M1  ; будет безусловно выполняться команда с меткой M1
```

*Директива*, как и команда, состоит из 4 полей:
`[<имя>]<код псевдооперации> <операнды> [;комментарии]`

+ *имя* -- символическое имя Ассемблера
+ Значение зависит от *кода псевдооперации* -- назначение директивы
  (например, выделить место в памяти или определить именованную
  константу)
+ Для одной и той же директивы может быть различное количество
  *операндов*, разделённых запятой.

Так же, как и в команде, поля разделяются одним пробелом. Так же
имеются комментарии.

*Примеры*:
```
M1 DB 1, 0, 1, 0, 1  ; Директива DB определяет 5 байтов в памяти
                     ; и записывает в них значения 1, 0, 1, 0, 1

Proc     ; Директива начала процедуры
endp     ; Директива конца процедуры
Segment  ; Директива начала сегмента
ends     ; Директива конца сегмента
```

Программа обычно состоит из 3 сегментов:
+ *Сегмента стека*

  В этом сегменте выделяется место под стек.

+ *Сегмента данных*

  В этом сегменте определяются исходные данные, выделяется место
  под промежуточные и окончательные результаты.

+ *Кодового сегмента*

  В этом сегменте реализуется алгоритм решения поставленной задачи.

  Сразу за директивой Segment должна присутствовать
  директива `ASSUME`, устанавливающая соответствие между именами
  сегментов и сегментными регистрами.

  Пример:
  `ASSUME SS:SSeg, DS:DSeg, CS:CSeg, ES:DSeg`

  Кодовый сегмент оформляется, как процедура, и это может быть как
  одна процедура, так и несколько последовательных, или это может
  быть вложенные процедуры.

  Шаблон кодового сегмента с вложенными процедурами можно
  представить так:

  ```
  Cseg Segment ...
  ASSUME SS:SSeg, DS:DSeg, CS:CSeg, ES:DSeg
  pr1 Proc Far
  -----/-----
    pr2 Proc
    ---/---
    pr2 endp
    ---/---
  pr1 endp
  Cseg ends
  ```

Базовый шаблон программы:

```
; сегмент стека
Sseg Segment ...
  DB 256 DUP(?)
Sseg ends

; сегмент данных
Dseg Segment ...
  X DB 'A'
  Y DB 'B'
  Z DB 'C'
Dseg ends

; Сегмент кода
Cseg Segment ...
  ASSUME SS:SSeg, DS:DSeg, CS:CSeg
  Start Proc FAR
    PUSH DS
    PUSH AX
    MOV DX, DSeg
    MOV DS, DX
    CALL Main
    Ret
  Start endp
  Main Proc NEAR
    ADD AL, X
    MOV AH, Y
    -----/-----
    Ret
  Main endp
Cseg ends

end Start
```

Программа реализована, как две последовательные процедура, одна
из них строки с 14 по 21 является внешней (об этом говорит
параметр `FAR` в директиве `PROC`), а это значит, что к этой
процедуре можно обратиться из любого другого кодового сегмента.

Наша внешняя процедура сохраняет в стеке значения сегмента данных
`PUSH DS` и пустое слово `PUSH AX`. После чего она загружает в
регистр DS адрес нашего сегмента данных, с которым мы собираемся
работать с помощью промежуточного регистра DX. Потом мы обращаемся
к процедуре с именем `Main`.

Процедура `Main` является внутренней (параметр `NEAR`), то есть
к ней можно обратиться только из того кодового сегмента, в котором
содержится её описание.

В процедуре `Main` содержаться команды, реализующие решение задачи.
Команда `Ret` осуществляет возврат в вызвавшую её программу (в
процедуру с именем `Start` к команде, следующей за `CALL`).

За `CALL` написана команда `Ret`, которая реализует выход из
программы в ОС.

`end Start` -- устанавливает точку входа -- процедуру `Start`.

= Слова, константы, выражения, переменные

*Символические имена* в Ассемблере могут состоять из строчных и
прописных букв латинского алфавита (регистр не учитывается), цифр
и некоторых символов.

*Константы бывают несколько типов*:
+ *Целых двоичные, десятичные, шестнадцатиричные*

  _Целые двоичные_ -- последовательность нулей и единицы, которые
  оканчиваются на `b`.

  _Десятичные_ -- обычная запись положительных и отрицательных чисел
  либо без буквы в конце, либо с буквой `d`

  _Шестнадцатиричные_ -- последовательность 16-ричных цифр, которая
  оканчивается буквой `h`. Если такая константа начинается с
  цифры `A`, `B`, `C`, `D`, `E`, перед ей нужно написать цифру `0`,
  иначе это будет восприниматься, как символическая ссылка.

+ *Действительные с плавающей точкой*;

  Пример: `34.751e+02` -- это 345,1

+ *Символьные и строковые*

  _Строковые данные_ -- последовательность символов, которая
  заключена в апострофы или кавычки.

Именнованные константы: `M EQU 27`.

*ВАЖНО, на экзамене часто на это не отвечают!*

*Переменные* в Ассемблере определяются с помощью директив `DB`,
`DW` и так далее.

```
v1 DB 7
v2 DW 34
```

Или с помощью директивы знака равенства:

```
v3 = 100
v3 = v3 + 1
```

Константы могут использоваться в директивах определения данных
и памяти, как непосредственные операнды в выражениях.

*Выражения* в Ассемблере, так же как и во всех других языках,
бывают
+ Арифметические
+ Логические
+ Строковые

Строятся они из *операндов* и *операторов*.

Операндами могут быть константы или переменные, а операторы --
это знаки операций.

*Тип операций*

+ *Арифметические операции* -- `+`, `-`, `*`, `/`
+ *Логические операции* -- NOT, AND, OR, XOR
+ *Логические операции* -- LT, LE, EQ, NE, GT, GE
+ *Сдвиг влево и вправо* -- SHL и SHR соответственно
+ *Специальные* -- `OFFSET имя`, именем может быть метка или
  переменная, а значением является адрес имени (смещение)

*Тип операндов*

+ BYTE -- 1 байт
+ WORD -- 2 байт
+ DWORD -- 4 байт
+ FWORD -- 6 байт
+ QWORD -- 8 байт
+ TWORD -- 10 байт
+ Тип вызова `NEAR` или `FAR` (В `Proc`, если не указать,
  по-умолчанию `NEAR`)

_Пример_: 10010101h + 37d

= Директива определения данных и памяти

*Общий вид* -- [`имя`] DX `<операнды>` `<;комментарии>`, где X --
R, W, D, E, Q или T.

В качестве операнда может быть `?` или несколько констант,
разделённых запятой.

Имя, если оно есть, определяет адрес первого байта выделяемой
области.

Директива определяет в памяти указанное количество байт и
записывает в указанные поля указанные поля или ничего, если
операндом является `?`.

_Примеры:_
+ `R1 DB 0, 0, 0` -- выделено три байта, заполненных 0.
+ `R2 DB ?, ?, ? R2` -- в них ничего не записали и там могут быть
  случайные величины

Но если мы символическому имени уже присвоили некоторое значение,
а затем использовали в качестве операнда, то именно это значение
записывается в выделенную область памяти

_Пример:_
```
M DD IM1  ; выделим 4 байта памяти, адрес этого поля присваивает
          ; переменной M, а внутри памяти значение IM1
```

Также можно написать так:
```
D DB 100 DUP (1)  ; выделить 100 байт памяти и заполнить их 1
                  ; выделяем место в памяти и 100 раз продублировали
```

Определяем массив:
```
MAS DW 1, 7, 25, 75, 84  ; Массив слов

Arr DB   7, 94, 11, 5    ; Двумерный массив
    DB   5, 0,  1,  2
    DB   -5, 0, 15, 24
```

С помощью директивы определения байта мы можем определить строковую
константу длинной 255 символов, а с помощью директивы определения
слова можно определить только двухсимвольную константу.
